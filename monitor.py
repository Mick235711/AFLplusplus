#!/usr/bin/env python3

""" Monitor the crash case generated by AFL """

# Libraries
import argparse
import io
import os
import selectors
import sys
import shutil
import subprocess
from typing import Any, Callable, TextIO, override
from watchdog.events import FileSystemEventHandler, FileCreatedEvent, \
    FileSystemEvent
from watchdog.observers import Observer


class CrashMonitor(FileSystemEventHandler):
    """ Monitor a crash directory """

    def __init__(
        self, output_dir: str,
        run_official: Callable[[str, str], str],
        run_custom: Callable[[str, str], str]
    ) -> None:
        """ Constructor """
        super().__init__()
        assert os.path.isdir(output_dir), output_dir
        self.output_dir = output_dir
        self.run_official = run_official
        self.run_custom = run_custom

    @override
    def on_created(self, event: FileSystemEvent) -> None:
        """ Event representing file/dir creation """
        if not isinstance(event, FileCreatedEvent):
            return
        path = event.src_path
        print(f"\n=====> Detected new crash case: {path}")


def run_afl_tmin(
    afl_tmin_binary: str, test_case_dir: str, execute_line: list[str]
) -> Callable[[str, str], str]:
    """ Run afl-tmin, return the output """
    def runner(crash_case: str, crash_reduce: str) -> str:
        # Create process
        process = subprocess.Popen(
            [afl_tmin_binary, "-i", crash_case, "-o", crash_reduce,
             "-d", test_case_dir, "--"] + execute_line,
            bufsize=1, universal_newlines=True,
            stdout=subprocess.PIPE, stderr=subprocess.STDOUT
        )

        # Create callback function for process output
        buf = io.StringIO()

        def handle_output(stream: TextIO, _: Any) -> None:
            # Because the process' output is line buffered, there's only ever
            # one line to read when this function is called
            line = stream.readline()
            buf.write(line)
            sys.stdout.write(line)

        # Register callback for an "available for read" event
        selector = selectors.DefaultSelector()
        selector.register(
            process.stdout,  # type: ignore
            selectors.EVENT_READ, handle_output
        )

        # Loop until subprocess is terminated
        while process.poll() is None:
            # Wait for events and handle them with their registered callbacks
            events = selector.select()
            for key, mask in events:
                callback = key.data
                callback(key.fileobj, mask)

        # Get process return code
        return_code = process.wait()
        selector.close()

        if return_code != 0:
            print(f"Warning: the process returned {return_code}!")

        # Store buffered output
        output = buf.getvalue()
        buf.close()

        return output
    return runner


def main() -> None:
    """ Main function """
    parser = argparse.ArgumentParser()
    parser.add_argument("-i", "--input-dir",
                        help="AFL crash directory to monitor")
    parser.add_argument("-o", "--output-dir", help="Output directory")
    parser.add_argument("-d", "--test-case-dir", help="Testcase directory")
    parser.add_argument("--official", help="Path to official afl-tmin")
    parser.add_argument("--custom", help="Path to custom afl-tmin")
    parser.add_argument("binary", nargs="+",
                        help="Testing binary (@@ for filename)")
    args = parser.parse_args()
    assert os.path.isdir(args.input_dir), args.input_dir
    assert os.path.isdir(args.test_case_dir), args.test_case_dir
    assert os.path.isfile(args.official), args.official
    assert os.path.isfile(args.custom), args.custom
    if os.path.exists(args.output_dir):
        shutil.rmtree(args.output_dir)
    os.makedirs(args.output_dir)

    observer = Observer()
    observer.schedule(
        CrashMonitor(
            args.output_dir,
            run_afl_tmin(args.official, args.test_case_dir, args.binary),
            run_afl_tmin(args.custom, args.test_case_dir, args.binary)
        ), args.input_dir, recursive=False
    )
    observer.start()
    try:
        while observer.is_alive():
            observer.join(1)
    finally:
        observer.stop()
        observer.join()


# Call main
if __name__ == "__main__":
    main()
